// lib/pages/png_transisi_stage_route.dart

import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import '../widgets/alpha_video_player.dart';

/// PngTransisiStageRoute — overlay-first mode
/// Overlay (PNG animation) dimulai duluan.
/// Stage (pageUnder) mulai berjalan setelah n frame overlay (default 1).
class PngTransisiStageRoute extends PageRoute<void> {
  final Widget pageUnder;
  final Uint8List? backgroundBytes;
  final String pngPattern;
  final int pngFrameCount;
  final int fps;
  final bool loop;
  final int bufferSize;
  final int? targetDisplayWidth;
  final int? targetDisplayHeight;
  final int
  stageStartFrames; // berapa frame overlay sebelum stage mulai (default 1)
  final Duration initialDelay;
  final Duration endFrameDelay;
  final bool overlayFadeOut;
  final Duration overlayFadeDuration;
  final Duration initialFreeze;

  /// NEW:
  /// Jika diberikan, route akan menunggu future ini selesai sebelum menampilkan pageUnder.
  /// Jika null -> dianggap siap segera.
  final Future<void>? pageReadyFuture;
  final Duration pageReadyTimeout;

  PngTransisiStageRoute({
    required this.pageUnder,
    this.backgroundBytes,
    required this.pngPattern,
    required this.pngFrameCount,
    this.fps = 24,
    this.loop = false,
    this.bufferSize = 8,
    this.targetDisplayWidth,
    this.targetDisplayHeight,
    this.stageStartFrames = 1, // default: mulai setelah 1 frame
    this.initialDelay = Duration.zero,
    this.endFrameDelay = const Duration(milliseconds: 140),
    this.overlayFadeOut = true,
    this.overlayFadeDuration = const Duration(milliseconds: 240),
    this.initialFreeze = const Duration(milliseconds: 500),
    this.pageReadyFuture,
    this.pageReadyTimeout = const Duration(milliseconds: 800),
  });

  @override
  Duration get transitionDuration => Duration.zero;
  @override
  Duration get reverseTransitionDuration => Duration.zero;
  @override
  bool get maintainState => true;
  @override
  bool get opaque => true;
  @override
  Color? get barrierColor => null;
  @override
  String? get barrierLabel => null;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> a1,
    Animation<double> a2,
  ) {
    // Hitung delay start stage dari frame count (mis. 1 frame @24fps = ~41.6ms)
    final stageStartDelay = Duration(
      milliseconds: ((1000 / fps) * stageStartFrames).round(),
    );

    return Scaffold(
      backgroundColor: Colors.black,
      body: _StageOverlayBody(
        pageUnder: pageUnder,
        backgroundBytes: backgroundBytes,
        pngPattern: pngPattern,
        pngFrameCount: pngFrameCount,
        fps: fps,
        loop: loop,
        bufferSize: bufferSize,
        targetDisplayWidth: targetDisplayWidth,
        targetDisplayHeight: targetDisplayHeight,
        initialDelay: initialDelay,
        stageStartDelay: stageStartDelay, // auto dihitung dari FPS
        endFrameDelay: endFrameDelay,
        initialFreeze: initialFreeze,
        pageReadyFuture: pageReadyFuture,
        pageReadyTimeout: pageReadyTimeout,
      ),
    );
  }
}

class _StageOverlayBody extends StatefulWidget {
  final Widget pageUnder;
  final Uint8List? backgroundBytes;
  final String pngPattern;
  final int pngFrameCount;
  final int fps;
  final bool loop;
  final int bufferSize;
  final int? targetDisplayWidth;
  final int? targetDisplayHeight;
  final Duration initialDelay; // delay before starting overlay (usually zero)
  final Duration stageStartDelay; // when pageUnder should start (e.g. 500ms)
  final Duration
  endFrameDelay; // small wait after overlay finished before hiding
  final Duration initialFreeze; // how long to hold first frame (default 500ms)

  /// NEW:
  final Future<void>? pageReadyFuture;
  final Duration pageReadyTimeout;

  const _StageOverlayBody({
    required this.pageUnder,
    this.backgroundBytes,
    required this.pngPattern,
    required this.pngFrameCount,
    required this.fps,
    required this.loop,
    required this.bufferSize,
    required this.targetDisplayWidth,
    required this.targetDisplayHeight,
    required this.initialDelay,
    required this.stageStartDelay,
    required this.endFrameDelay,
    this.initialFreeze = const Duration(milliseconds: 500),
    this.pageReadyFuture,
    this.pageReadyTimeout = const Duration(milliseconds: 800),
  });

  @override
  State<_StageOverlayBody> createState() => _StageOverlayBodyState();
}

class _StageOverlayBodyState extends State<_StageOverlayBody> {
  // overlay visibility
  bool _showOverlay = true;

  // freeze first frame visible for `initialFreeze` OR until player reports first frame / preload done
  bool _firstFrameFrozen = true;

  // whether stage (pageUnder) has been started/rendered
  bool _stageStarted = false;

  // whether alpha sequence finished
  bool _finished = false;

  // whether player has actually rendered its first frame
  bool _playerFirstFrameShown = false;

  // whether pageUnder reported ready (via provided future) or default true
  bool _pageReady = false;

  // cached path for first frame (if pngPattern contains %04d)
  late final String _firstFramePath;

  // Completers used to coordinate readiness
  late final Completer<void> _preloadReadyCompleter;
  late final Completer<void> _stageDelayCompleter;

  @override
  void initState() {
    super.initState();

    // prepare first-frame asset path if pattern uses %04d
    if (widget.pngPattern.contains('%04d')) {
      _firstFramePath = widget.pngPattern.replaceAll(
        '%04d',
        1.toString().padLeft(4, '0'),
      );
    } else {
      _firstFramePath = widget.pngPattern
          .replaceAll('%d', 1.toString())
          .replaceAll('%04', '0001');
    }

    // initialize completers
    _preloadReadyCompleter = Completer<void>();
    _stageDelayCompleter = Completer<void>();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;

      // Ensure first frame is precached immediately so static frame shows instantly.
      try {
        precacheImage(AssetImage(_firstFramePath), context).catchError((_) {});
      } catch (_) {
        // ignore
      }

      // Optional initialDelay before starting any logic (kept for compatibility)
      if (widget.initialDelay > Duration.zero) {
        Future.delayed(widget.initialDelay, () {
          if (!mounted) return;
          // no visual change here
        });
      }

      // keep showing frozen first frame until player signals readiness (or until fallback)
      setState(() {
        _firstFrameFrozen = true;
      });

      // Fallback: after initialFreeze, if player hasn't signaled readiness, unfreeze
      Future.delayed(widget.initialFreeze, () {
        if (!mounted) return;
        if (!_playerFirstFrameShown) {
          setState(() {
            _firstFrameFrozen = false;
          });
          if (!_preloadReadyCompleter.isCompleted) {
            _preloadReadyCompleter.complete();
          }
        }
      });

      // schedule stageStartDelay completer (frame-based small delay)
      if (widget.stageStartDelay > Duration.zero) {
        Future.delayed(widget.stageStartDelay, () {
          if (!mounted) return;
          if (!_stageDelayCompleter.isCompleted)
            _stageDelayCompleter.complete();
        });
      } else {
        if (!_stageDelayCompleter.isCompleted) _stageDelayCompleter.complete();
      }

      // NEW: wait for pageReadyFuture (with timeout) if provided
      if (widget.pageReadyFuture != null) {
        // race between the provided future and timeout
        widget.pageReadyFuture!
            .then((_) {
              if (!mounted) return;
              _pageReady = true;
            })
            .catchError((_) {
              // ignore errors but mark ready to avoid stalling
              if (!mounted) return;
              _pageReady = true;
            })
            .whenComplete(() {
              // ensure we proceed once either future completes
            });

        // also schedule a timeout fallback
        Future.delayed(widget.pageReadyTimeout, () {
          if (!mounted) return;
          if (!_pageReady) {
            // timeout - consider page ready (avoids waiting forever)
            _pageReady = true;
          }
        });
      } else {
        // no future provided -> immediately mark ready
        _pageReady = true;
      }

      // Wait for preload readiness AND stage delay AND page readiness before showing pageUnder.
      Future.wait([
        _preloadReadyCompleter.future,
        _stageDelayCompleter.future,
      ]).then((_) async {
        // Now wait until _pageReady becomes true (it may be set via future or immediate)
        final sw = Stopwatch()..start();
        while (!_pageReady &&
            sw.elapsed <
                widget.pageReadyTimeout + const Duration(milliseconds: 50)) {
          // poll small interval; this keeps us responsive to mounted state
          await Future.delayed(const Duration(milliseconds: 16));
          if (!mounted) return;
        }
        if (!mounted) return;

        setState(() {
          // now we're allowed to start the stage (unhide pageUnder)
          _stageStarted = true;
        });
      });
    });
  }

  // Called when AlphaVideoPlayer signals finished
  Future<void> _onAlphaFinished() async {
    if (_finished) return;
    _finished = true;

    // little extra delay for last frame
    await Future.delayed(widget.endFrameDelay);
    if (!mounted) return;

    // NO fade — hide overlay immediately (hard cut)
    setState(() {
      _showOverlay = false;
    });
  }

  // Called when AlphaVideoPlayer reports it has rendered first frame / preload ready
  void _onPlayerFirstFrame() {
    if (!mounted) return;
    if (_playerFirstFrameShown) return;
    _playerFirstFrameShown = true;

    // remove the frozen static frame so the actual first frame from player becomes visible
    setState(() {
      _firstFrameFrozen = false;
    });

    // complete preload completer so stage start can proceed (if waiting)
    if (!_preloadReadyCompleter.isCompleted) {
      _preloadReadyCompleter.complete();
    }
  }

  @override
  Widget build(BuildContext context) {
    // We'll mount the AlphaVideoPlayer immediately (to let it start preloading),
    // but overlay a static first-frame image on top while _firstFrameFrozen is true.
    final alphaPlayer = AlphaVideoPlayer(
      webmAsset: '',
      pngPattern: widget.pngPattern,
      pngFrameCount: widget.pngFrameCount,
      fps: widget.fps,
      loop: widget.loop,
      forceUseWebm: false,
      onFinished: _onAlphaFinished,
      // request prioritized preload of the first N frames (AlphaVideoPlayer supports this)
      initialPreloadFrames: 24,
      loadRestAfterPreload: true,
      onPreloadReady: _onPlayerFirstFrame,
      onFirstFrameRendered: _onPlayerFirstFrame,
      fit: BoxFit.cover,
      bufferSize: widget.bufferSize,
      targetDisplayWidth: widget.targetDisplayWidth,
      targetDisplayHeight: widget.targetDisplayHeight,
    );

    return Stack(
      fit: StackFit.expand,
      children: [
        // 1) pageUnder - kept OFFSTAGE until both stage started AND pageReady.
        //    This prevents "next page" flicker when its assets aren't ready.
        Positioned.fill(
          child: Offstage(
            offstage: !_stageStarted || !_pageReady,
            child: widget.pageUnder,
          ),
        ),

        // 2) overlay group (player + optional static frame)
        //    ignore pointers only when both stage started AND pageReady so pageUnder becomes interactive.
        Positioned.fill(
          child: IgnorePointer(
            ignoring:
                _stageStarted &&
                _pageReady, // overlay won't block taps only after page is ready & started
            child: Stack(
              fit: StackFit.expand,
              children: [
                // the alpha player: kept OFFSTAGE while frozen so it is mounted & preloads
                Offstage(
                  offstage:
                      _firstFrameFrozen, // true => hidden but still mounted
                  child: alphaPlayer,
                ),

                // static first-frame overlaid while frozen (precached earlier)
                if (_firstFrameFrozen)
                  Positioned.fill(child: _buildFirstFrameWidget()),
              ],
            ),
          ),
        ),

        // 3) in case we want to keep a visible cover while pageUnder is not yet ready,
        //    we keep showing the static first-frame or black background (already handled above).
      ],
    );
  }

  Widget _buildFirstFrameWidget() {
    // If backgroundBytes provided, try to use it; else try to use asset path pattern.
    if (widget.backgroundBytes != null) {
      return Image.memory(
        widget.backgroundBytes!,
        fit: BoxFit.cover,
        gaplessPlayback: true,
        width: double.infinity,
        height: double.infinity,
      );
    }

    // Try to load first frame from assets using computed path
    try {
      return Image.asset(
        _firstFramePath,
        fit: BoxFit.cover,
        gaplessPlayback: true,
        width: double.infinity,
        height: double.infinity,
        errorBuilder: (_, __, ___) {
          // fallback to plain black if asset missing
          return Container(color: Colors.black);
        },
      );
    } catch (_) {
      return Container(color: Colors.black);
    }
  }
}
