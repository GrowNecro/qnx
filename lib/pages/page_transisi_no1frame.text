// lib/pages/png_transisi_stage_route.dart

import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';
import '../widgets/alpha_video_player.dart';

/// PngTransisiStageRoute â€” overlay-first mode
/// Overlay (PNG animation) dimulai duluan.
/// Stage (pageUnder) mulai berjalan setelah n frame overlay (default 1).
class PngTransisiStageRoute extends PageRoute<void> {
  final Widget pageUnder;
  final Uint8List? backgroundBytes;
  final String pngPattern;
  final int pngFrameCount;
  final int fps;
  final bool loop;
  final int bufferSize;
  final int? targetDisplayWidth;
  final int? targetDisplayHeight;
  final int stageStartFrames; // berapa frame overlay sebelum stage mulai (default 1)
  final Duration initialDelay;
  final Duration endFrameDelay;
  final bool overlayFadeOut;
  final Duration overlayFadeDuration;
  final Duration initialFreeze;

  /// audio support
  final String? audioAsset;
  final bool audioLoop;
  final bool initialAudioMuted;

  /// Jika diberikan, route akan menunggu future ini selesai sebelum menampilkan pageUnder.
  final Future<void>? pageReadyFuture;
  final Duration pageReadyTimeout;

  PngTransisiStageRoute({
    required this.pageUnder,
    this.backgroundBytes,
    required this.pngPattern,
    required this.pngFrameCount,
    this.fps = 24,
    this.loop = false,
    this.bufferSize = 8,
    this.targetDisplayWidth,
    this.targetDisplayHeight,
    this.stageStartFrames = 1,
    this.initialDelay = Duration.zero,
    this.endFrameDelay = const Duration(milliseconds: 140),
    this.overlayFadeOut = true,
    this.overlayFadeDuration = const Duration(milliseconds: 240),
    this.initialFreeze = const Duration(milliseconds: 500),
    this.audioAsset,
    this.audioLoop = true,
    this.initialAudioMuted = false,
    this.pageReadyFuture,
    this.pageReadyTimeout = const Duration(milliseconds: 800),
  });

  @override
  Duration get transitionDuration => Duration.zero;
  @override
  Duration get reverseTransitionDuration => Duration.zero;
  @override
  bool get maintainState => true;
  @override
  bool get opaque => true;
  @override
  Color? get barrierColor => null;
  @override
  String? get barrierLabel => null;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> a1,
    Animation<double> a2,
  ) {
    final stageStartDelay = Duration(
      milliseconds: ((1000 / fps) * stageStartFrames).round(),
    );

    return Scaffold(
      backgroundColor: Colors.black,
      body: _StageOverlayBody(
        pageUnder: pageUnder,
        backgroundBytes: backgroundBytes,
        pngPattern: pngPattern,
        pngFrameCount: pngFrameCount,
        fps: fps,
        loop: loop,
        bufferSize: bufferSize,
        targetDisplayWidth: targetDisplayWidth,
        targetDisplayHeight: targetDisplayHeight,
        initialDelay: initialDelay,
        stageStartDelay: stageStartDelay,
        endFrameDelay: endFrameDelay,
        initialFreeze: initialFreeze,
        pageReadyFuture: pageReadyFuture,
        pageReadyTimeout: pageReadyTimeout,
        audioAsset: audioAsset,
        audioLoop: audioLoop,
        initialAudioMuted: initialAudioMuted,
      ),
    );
  }
}

class _StageOverlayBody extends StatefulWidget {
  final Widget pageUnder;
  final Uint8List? backgroundBytes;
  final String pngPattern;
  final int pngFrameCount;
  final int fps;
  final bool loop;
  final int bufferSize;
  final int? targetDisplayWidth;
  final int? targetDisplayHeight;
  final Duration initialDelay; // delay before starting overlay (usually zero)
  final Duration stageStartDelay; // when pageUnder should start (e.g. 500ms)
  final Duration endFrameDelay; // small wait after overlay finished before hiding
  final Duration initialFreeze; // kept for compatibility but no static-first-frame logic now

  final Future<void>? pageReadyFuture;
  final Duration pageReadyTimeout;

  // audio
  final String? audioAsset;
  final bool audioLoop;
  final bool initialAudioMuted;

  const _StageOverlayBody({
    required this.pageUnder,
    this.backgroundBytes,
    required this.pngPattern,
    required this.pngFrameCount,
    required this.fps,
    required this.loop,
    required this.bufferSize,
    required this.targetDisplayWidth,
    required this.targetDisplayHeight,
    required this.initialDelay,
    required this.stageStartDelay,
    required this.endFrameDelay,
    this.initialFreeze = const Duration(milliseconds: 500),
    this.pageReadyFuture,
    this.pageReadyTimeout = const Duration(milliseconds: 800),
    this.audioAsset,
    this.audioLoop = true,
    this.initialAudioMuted = false,
  });

  @override
  State<_StageOverlayBody> createState() => _StageOverlayBodyState();
}

class _StageOverlayBodyState extends State<_StageOverlayBody> {
  // overlay visibility
  bool _showOverlay = true;

  // whether stage (pageUnder) has been started/rendered
  bool _stageStarted = false;

  // whether alpha sequence finished
  bool _finished = false;

  // whether preload event signaled by AlphaVideoPlayer happened
  bool _preloadReady = false;

  // whether pageUnder reported ready (via provided future) or default true
  bool _pageReady = false;

  // Completers used to coordinate readiness
  late final Completer<void> _preloadReadyCompleter;
  late final Completer<void> _stageDelayCompleter;

  // AUDIO
  VideoPlayerController? _audioController;
  bool _audioInitialized = false;
  bool _audioMuted = false;
  bool _audioAvailable = false;

  @override
  void initState() {
    super.initState();

    _preloadReadyCompleter = Completer<void>();
    _stageDelayCompleter = Completer<void>();

    if (widget.audioAsset != null) {
      _initAudio(widget.audioAsset!, widget.audioLoop, widget.initialAudioMuted);
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;

      // Optional initialDelay (retained for compatibility)
      if (widget.initialDelay > Duration.zero) {
        Future.delayed(widget.initialDelay, () {
          if (!mounted) return;
        });
      }

      // schedule stageStartDelay completer (frame-based small delay)
      if (widget.stageStartDelay > Duration.zero) {
        Future.delayed(widget.stageStartDelay, () {
          if (!mounted) return;
          if (!_stageDelayCompleter.isCompleted) _stageDelayCompleter.complete();
        });
      } else {
        if (!_stageDelayCompleter.isCompleted) _stageDelayCompleter.complete();
      }

      // wait for pageReadyFuture (with timeout) if provided
      if (widget.pageReadyFuture != null) {
        widget.pageReadyFuture!.then((_) {
          if (!mounted) return;
          _pageReady = true;
        }).catchError((_) {
          if (!mounted) return;
          _pageReady = true;
        });

        // timeout fallback
        Future.delayed(widget.pageReadyTimeout, () {
          if (!mounted) return;
          if (!_pageReady) _pageReady = true;
        });
      } else {
        _pageReady = true;
      }

      // Wait for preload readiness AND stage delay, then check page readiness before starting stage.
      Future.wait([_preloadReadyCompleter.future, _stageDelayCompleter.future]).then((_) async {
        // poll until pageReady or timeout
        final sw = Stopwatch()..start();
        while (!_pageReady && sw.elapsed < widget.pageReadyTimeout + const Duration(milliseconds: 50)) {
          await Future.delayed(const Duration(milliseconds: 16));
          if (!mounted) return;
        }
        if (!mounted) return;

        setState(() {
          _stageStarted = true;
        });
      });
    });
  }

  Future<void> _initAudio(String asset, bool loop, bool initialMuted) async {
    try {
      _audioController = VideoPlayerController.asset(asset);
      await _audioController!.initialize();
      _audioController!.setLooping(loop);
      _audioMuted = initialMuted;
      _audioInitialized = true;
      _audioAvailable = true;
      await _audioController!.setVolume(_audioMuted ? 0.0 : 1.0);
      _audioController!.play();
    } catch (e) {
      _audioAvailable = false;
      _audioInitialized = false;
    }
    if (mounted) setState(() {});
  }

  // Called when AlphaVideoPlayer signals finished
  Future<void> _onAlphaFinished() async {
    if (_finished) return;
    _finished = true;

    await Future.delayed(widget.endFrameDelay);
    if (!mounted) return;

    if (_audioController != null && _audioAvailable) {
      try {
        await _audioController!.pause();
        await _audioController!.seekTo(Duration.zero);
      } catch (_) {}
    }

    setState(() {
      _showOverlay = false;
    });
  }

  // Called when AlphaVideoPlayer reports preload ready or first frame rendered
  void _onPreloadReady() {
    if (!mounted) return;
    if (_preloadReady) return;
    _preloadReady = true;
    if (!_preloadReadyCompleter.isCompleted) _preloadReadyCompleter.complete();
  }

  @override
  void dispose() {
    if (_audioController != null) {
      try {
        _audioController!.dispose();
      } catch (_) {}
      _audioController = null;
    }
    super.dispose();
  }

  void _toggleAudioMute() async {
    if (!_audioAvailable || _audioController == null) return;
    setState(() {
      _audioMuted = !_audioMuted;
    });
    try {
      await _audioController!.setVolume(_audioMuted ? 0.0 : 1.0);
      if (!_audioMuted && !_audioController!.value.isPlaying) {
        await _audioController!.play();
      }
    } catch (_) {}
  }

  @override
  Widget build(BuildContext context) {
    final alphaPlayer = AlphaVideoPlayer(
      webmAsset: '',
      pngPattern: widget.pngPattern,
      pngFrameCount: widget.pngFrameCount,
      fps: widget.fps,
      loop: widget.loop,
      forceUseWebm: false,
      onFinished: _onAlphaFinished,
      initialPreloadFrames: 24,
      loadRestAfterPreload: true,
      onPreloadReady: _onPreloadReady,
      onFirstFrameRendered: _onPreloadReady,
      fit: BoxFit.cover,
      bufferSize: widget.bufferSize,
      targetDisplayWidth: widget.targetDisplayWidth,
      targetDisplayHeight: widget.targetDisplayHeight,
    );

    return Stack(
      fit: StackFit.expand,
      children: [
        // 1) pageUnder - instantiate & show only when _stageStarted && _pageReady
        if (_stageStarted && _pageReady) Positioned.fill(child: widget.pageUnder),

        // 2) overlay group (player)
        Positioned.fill(
          child: IgnorePointer(
            // block interactions while overlay still "owns" the screen
            ignoring: _stageStarted && _pageReady,
            child: Stack(
              fit: StackFit.expand,
              children: [
                // show the alpha player directly (no static first-frame)
                Positioned.fill(child: alphaPlayer),

                // optional audio control while overlay visible
                if (_showOverlay && _audioAvailable)
                  Positioned(
                    top: 18,
                    right: 12,
                    child: SafeArea(
                      minimum: const EdgeInsets.all(4),
                      child: Material(
                        color: Colors.black.withOpacity(0.35),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
                        child: IconButton(
                          padding: const EdgeInsets.all(6),
                          iconSize: 20,
                          tooltip: _audioMuted ? 'Unmute' : 'Mute',
                          icon: Icon(
                            _audioMuted ? Icons.volume_off : Icons.volume_up,
                            color: Colors.white,
                          ),
                          onPressed: _audioInitialized ? _toggleAudioMute : null,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}
